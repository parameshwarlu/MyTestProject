Current process while doing mobile and web application automation validations with mainframe system.

	->   For DigiBank both (Mobile and Web Applications) there were many modules which uses CIS (IBM Mainframe) as backend downstream system. So there were 500+ of scenarios where validation should be done with mainframe values vs Mobile/web UI values.

	->   In the existing Mobile Framework there was no feasibility to connect to CIS – Mainframe (As it’s a desktop application) so there was no way to automate mainframe. Hence Automation team/PO/Manual QA team used to connect mainframe manually and captures screenshots manually and then they used to validate our automation reports with respect to their captured mainframe screenshot values.

gaps

After the automation execution done (both Mobile, Web), we used to connect to mainframe manually, capture the screenshots and save them in reports folder and used to compare the ui / mainframe values manually which consumes lot of time.

used to connect to Mainframe manually
used to navigate to the different screens like (dffa, df70 etc..) to note down the filed values in mainframe
used to take the screenshots of those mainframe screens manually for future reference.
used to download our automation reports and start comparing the UI values and mainframe values manually
Sometimes manual team/ PO used to do these mainframe and reports validation. So they used to revert us if there is a mismatch or validation failure happens after their comparison done manually which results delay in finding defect.
Once PO fails that failed cases, we used to fail the case and follow up with developer by raising a new defect.
Once Developer fixes bug, then we used to run our automation script once again and then they used to do validation again manually..

pro sol

Below activities are automated.
Connecting to the Mainframe Desktop application automated in the same existing framework.
Written many reusable methods to navigate to the different screens directly just by passing the screenname, region names as arguments to those methods.
Capturing mainframe screenshots automated.
Written reusable methods which takes mainframe values and UI values, and compares them returns the Boolean value like pass or fail
Mainframe screenshots and validation results everything shown up on the same automation report.
As automation team only validating UI and mainframe values, finding defect has become early instead of finding it by PO.


suer ben

Across all the projects/modules whoever needs mainframe validations in their scenarios, they can instantly start automate their respective mainframe screens.

qual benefits

This Mainframe Integration for existing framework will save effort of around (10 mnts for each TC) * (10 TC per day) = 100 min per day. per year for individual resource considering 20 working days per month 20 * 100 = 2000/60 =33.3 hrs/month. So per year for individual resource 33.3 hrs * 12 months = 400 hours. If we execute more, cost savings will increase based on test scripts executed
Manual Effort - 21 Mins (Approx. 10 images)

Manual Effort - 21 Mins (Approx. 10 images)
1.Connect Mainframe– 1 min 2.Navigate to respective screen to capture the values – 2 mins 3. Capturing screenshots and saving them into folder – 2 mins 4.Compare those screenshot values with UI valuesn– 3 mins 5.Adding screenshots manually to the reports in jira and closing mainframe session – 2 min   Total Time : 10 mins
By Automating Mainframe
•All the manual steps from 1-5 can be done in less than 3 mins of time.

10 mins * 6 tests * 20 Days/60 mins
20
 hrs.
20 hrs. * 12 months
240
 hrs.
240 Hrs * 1,112.3 INR (Considering 8899/- for 8 hrs billing)
2,66,952 
rs

Tester can easily write the scripts to automate mainframe and easily compares those values with UI values.
This is very skillfulness in avoiding wasted time and efforts.
Improves productivity of the tester.


Technology Environment
  Java  Selenium Webdriver

------
zephyr

Current process for uploading automation results to JIRA test case:

	->   For DigiBank both (Mobile and Web Applications), once the automation execution completes we used to copy that report manually, zip it and then manually upload that report to respective jira test case manually.

	->   Then PO/ Manual QA or whoever want to validate those results used to download that report from respective test case for review.

  case studies
  After the automation execution done (both Mobile, Web)

used to copy the report folder manually form Reports folder.
used to zip that report manually.
Connect to JIRA by providing logins manually.
Open JIRA test case manually then upload the zipped report their.

prop solu

Below activities are automated.

Once the automation script execution completed the last step will take care below:

Developed the java code to connect to the JIRA directly through API calls.
Connect to the respective test story directly using API call and checks whether a respective test case available already.
If test case already available, attach the report directly their with comment saying (Automation report – TC Name).
If test case not available, it creates a new test case instantly with test scenario outline name and then attach the report their.

user benefitial

For all the projects/modules across the organization whoever uses this framework for automating mobile and web
For all the business users to track the automation reports directly and very instantly once the jobs executions completed

quantifi benefits

This Zephyr Integration for existing framework will save effort of around (5 mnts for each TC) * (10 TC per day) = 50 min per day. per year for individual resource considering 20 working days per month 20 * 50 = 1000/60 =16.6 hrs/month. So per year for individual resource 16.6 hrs * 12 months = 200 hours. If we execute more, cost savings will increase based on test scripts executed.
Manual Effort - 21 Mins (Approx. 10 images)
By Automating Mainframe
1.Open reports folder and zip – 1 min 2.Connect to JIRA and open respective test case – 2 mins 3. uploading the report, giving comment and then closing jira– 2 mins    Total Time : 5 mins
•All the manual steps from 1-5 can be done in less than 1 mins of time.


calculations
5 mins * 10 tests * 20 Days/60 mins
16.6
 hrs.
16.6 hrs. * 12 months
200
 hrs.
200 Hrs * 1,112.3 INR (Considering 8899/- for 8 hrs billing)
2,22,460
rs

Tester no need to write any script to attach the reports to respective jira test case as everything been automated as post execution mandate steps.
This is very skillfulness in avoiding wasted time and efforts.
Improves productivity of the tester.


Technology Environment
  Java  Selenium Webdriver


-------

git branching 

Current process for code push and scheduling jobs on Jenkins :

	->   We had only two sub branches in our bitbucket repo. Automation_3_2_1 branch for MB. Automation_IB branch for web. So Appium automation users uses 3_2_1 branch and web Automator uses IB branch to develop code.
	-> Problem here is automation users using the same branch for their everyday code development as well as Jenkins scheduled jobs.
	-> So if any of the automation user pushes the wrong code to branch mistakenly all the scheduled Jenkins jobs getting failed due to wrong code which impacting at business level as these jobs sends the reports directly to the business.

	->   Also there is a chance of code corrept due to wrong code as all using only one branch and there are no other levels to have the safe code.

gaps identified

After the automation execution done (both Mobile, Web)

Every automation tester directly working on parent branch instead creating a feature branch to work on.
There is no privilege restrictions for automation users so whoever having access can push the code directly to the main branch.
There is no process of creating pull requests to merge the code.
There is no code review happening due in which incorrect and directly going to master branch.
There is no levels of code like (Dev branch, QA branch, Release branch) instead maintaining total code in one branch. So changes of losing the safe code is high.
Jenkins jobs affecting due to compilation issues because of wrong code push.


proposed solution
 
Below new model has been introduced.

Firstly three layers of branches will be designed like Dev, QA and Release branches.
Dev Branch:
Dev branch will be the accessible code for every automation tester in the team. Team has to pull code from this branch then cut the feature branch, work on feature branch then merge that feature branch to Dev branch.
Automation tester will be having read/write access only to this branch. No access will be given to QA and Release branches.
Automation user will create a pull request to QA branch from Dev branch.
QA Branch:	
Code reviewer whoever have access to this branch will review the code then merges it into QA branch. This is like intermediate layer and the pull request frequency will be little high to this branch.
Then based on the needs (probably twice in a month), code reviewer will raise a PR to Release branch to directly merge the reviewed code to respective release branch.

Release Branch:
Release branches are only for (Sanity, Regression) testing. 
Jenkins jobs will take the code from Release branches and starts executing. 
Privileges access will be restricted. Only the Automation Team Lead/ higher level people will be having the access to this branches to approve the PR.
Due to this Automation tester cant touch this code base so code will be secured so jobs will be running smoothly without disturb.

user benefit

Though if wrong code pushes, as there are two more layers of code where actual Jenkins jobs running so jobs wont be impacted.
Secured code all the time. Many compilation and merge issues will be resolved due to this proper branching hierarchy.

Quantifiable Benefits



Wrong code pushes wont impact other QA’s code
Jenkin jobs wont be impacted
Compilation issues will be decreased
Due to code review, coding standards can be improved and wrong code won’t go to release branches.
Due to privilege access only authenticated members can access the QA and release branches. So secured code all the time.


Due to PR’s all the code can be tracked at any time.
